//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.IO;
using System.IO.Compression;

namespace ErysDownloader.Socket
{
	using System;
	using System.Collections.Generic;
	using System.Text;

	internal static class StreamHandle
	{
        public static void WriteLine(System.IO.Stream session, IEnumerable<string> commandLines)
        {
            var commands = new List<byte>();

            var lineTerminator = new byte[] { 13, 10 };

            foreach (string r in commandLines)
            {
                var data = Encoding.ASCII.GetBytes(r);
                commands.AddRange(data);
                commands.AddRange(lineTerminator);
                //WriteBuffer(session, data);
                //WriteBuffer(session, lineTerminator);
            }

            commands.AddRange(lineTerminator);
            //WriteBuffer(session, lineTerminator);

            WriteBuffer(session, commands.ToArray());
        }

        public static string ReadLineText(System.IO.Stream session)
        {
            var line = ReadLineBinary(session);
            return line == null ? null : Encoding.ASCII.GetString(line);
        }

        public static byte[] ReadLineBinary(System.IO.Stream session)
        {
            var lineBuffer = new List<byte>();

            while (true)
            {
                int b = session.ReadByte();
                if (b == -1) return null;
                if (b == 10) break;
                if (b != 13) lineBuffer.Add((byte)b);
            }

            return lineBuffer.ToArray();
        }

        public static StreamReader ToGzipSession(MemoryStream outputStream, Encoding charset, byte[] loadedBuffer)
        {
            //MemoryStream outputMemory = new MemoryStream();
            //int i = 0;

            //for (; i < loadedBuffer.Length; i++)
            //{
            //    //http://en.wikipedia.org/wiki/Magic_number_(programming)
            //    if (loadedBuffer[i] == 31 && loadedBuffer[i + 1] == 139)
            //        break;
            //}

            //byte[] dataFirtBlock = loadedBuffer.Skip(i).ToArray();
            //outputMemory.Write(dataFirtBlock, 0, loadedBuffer.Length - i);
            outputStream.Write(loadedBuffer, 0, loadedBuffer.Length);

            return new StreamReader(new GZipStream(outputStream, CompressionMode.Decompress), charset);
		}

        public static StreamReader ToDeflateSession(MemoryStream outputStream, Encoding charset, byte[] loadedBuffer)
		{
            //MemoryStream outputMemory = new MemoryStream();
            //int i = 0;

            //for (; i < loadedBuffer.Length; i++)
            //{
            //    //http://connect.microsoft.com/VisualStudio/feedback/details/97064/deflatestream-throws-exception-when-inflating-pdf-streams
            //    if (loadedBuffer[i] != 120 || loadedBuffer[i + 1] != 156) continue;

            //    i += 2;

            //    break;
            //}

            //i = loadedBuffer.Length == i ? 0 : i; // Se leu tudo e não achou os chars acima.
            //byte[] dataFirtBlock = loadedBuffer.Skip(i).ToArray();
            //outputMemory.Write(dataFirtBlock, 0, loadedBuffer.Length - i);

            outputStream.Write(loadedBuffer, 2, loadedBuffer.Length-2);

            return new StreamReader(new DeflateStream(outputStream, CompressionMode.Decompress), charset);
		}

        public static StreamReader ToAsciiSession(MemoryStream outputStream, Encoding charset, byte[] loadedBuffer)
        {
            outputStream.Write(loadedBuffer, 0, loadedBuffer.Length);
            return new StreamReader(outputStream, charset);//Encoding.GetEncoding("ISO-8859-1")
        }

        public static int LoadBuffer(System.IO.Stream stream, byte[] emptyBuffer) {

            if (!(emptyBuffer.Length > 0)) return 0;

            var read = 0;
            var totalToRead = emptyBuffer.Length;

            do
            {
                var toBuffer = new byte[totalToRead - read];
                var oldRead = read;


                read += stream.Read(toBuffer, 0, toBuffer.Length);

                for (int i = oldRead; i < read; i++)
                {
                    emptyBuffer[i] = toBuffer[i - oldRead];
                }

            } while (read < totalToRead);

            return read;

            //if (!(emptyBuffer.Length > 0)) return 0;

            //var read = stream.Read(emptyBuffer, 0, emptyBuffer.Length);

            //if (read < emptyBuffer.Length)
            //{
            //    var restBuffer = new byte[emptyBuffer.Length - read];

            //    var oldRead = read;

            //    read += LoadBuffer(stream, restBuffer);

            //    for (int i = oldRead; i < emptyBuffer.Length; i++)
            //    {
            //        emptyBuffer[i] = restBuffer[i - oldRead];
            //    }
            //}

            //return read;
        }

        public static void WriteBuffer(System.IO.Stream stream, byte[] loadedBuffer)
        {
            stream.Write(loadedBuffer, 0, loadedBuffer.Length);
        }

        /// <summary>
        /// Lê o transfer-encoding quando houver ou retorna 4096 quando não houver.
        /// </summary>
        public static byte[] GetBuffer(System.IO.Stream session, bool hasTransferEncoding, ref int contentLength)
        {
            if (hasTransferEncoding)
            {
                //byte[] chucked = ReadLineBinary(session);

                //if (chucked.Length == 0) chucked = ReadLineBinary(session);
                ////bytesReadTotal += chucked.Length;
                //string chunkValue = string.Empty;

                //foreach (byte ad in chucked) chunkValue += ((char)ad);

                string chunkValue = ReadLineText(session);
                if (string.IsNullOrWhiteSpace(chunkValue)) chunkValue = ReadLineText(session);

                chunkValue = chunkValue.Trim();

                contentLength = Convert.ToInt32(chunkValue, 16);

                // Poderia comentar esta linha para forçar ler no maximo 4096.
                // Porem, não foi testado mas na proxima interação dará erro ao ler a proxima linha(ReadLineText).
                return new byte[contentLength];
            }

            // Usando proxy na escola contentLength = -1. porque?
            // Testar/emular este este erro acessando site uol.
            return new byte[contentLength < 4096 && contentLength > 0 ? contentLength : 4096];
        }

        public static StreamReader OutputDecorator(MemoryStream outputStream, ContentEncoding contentEncoding, Encoding charset , byte[] loadedBuffer)
        {
		    StreamReader outputDecorator;

		    switch (contentEncoding) {
		        case ContentEncoding.Gzip:
                    outputDecorator = StreamHandle.ToGzipSession(outputStream, charset, loadedBuffer);
		            break;
		        case ContentEncoding.Deflate:
                    outputDecorator = StreamHandle.ToDeflateSession(outputStream, charset, loadedBuffer);
		            break;
		        default:
                    outputDecorator = StreamHandle.ToAsciiSession(outputStream, charset, loadedBuffer);
		            break;
		    }

		    return outputDecorator;
		}
	}
}

